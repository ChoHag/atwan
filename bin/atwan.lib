#!/bin/sh

check_arguments() {
  if [[ -v at_work_dir && ! -d "$at_work_dir" ]]; then
    echo Working directory $at_work_dir does not exist. >&2
    exit 
  fi

  if [[ -v at_cache_dir && ! -d "$at_cache_dir" ]]; then
    echo Cache directory $at_cache_dir does not exist. >&2
    exit 
  fi

  export at_lib_release="$at_lib/release/$at_release"
  if [[ "$at_release" =~ ^$|^[.-]|[/[:space:]] || ! -e "$at_lib_release/meta" ]]
  then
    echo Unknown OS release: $at_release. >&2
    echo Check $at_lib/release. >&2
    exit 1
  fi

  read_meta "$at_lib_release"/meta
  if [[ -v at_local_release_dir && -e "$at_local_release_dir"/meta ]]; then
    read_meta "$at_local_release_dir"/meta
  fi

  if [[ ! -v at_pubkey ]]; then
    export at_pubkey=$(gpg --list-secret-keys --with-colons|awk -F: '$1=="sec"{print$5}')
  else
    if ! gpg --list-secret-keys "$at_pubkey" >/dev/null; then
      echo WARNING: Cannot find signing key for "$at_pubkey". >&2
    fi
    if ! gpg --list-keys "$at_pubkey" >/dev/null; then
      echo Cannot find public key "$at_pubkey". >&2
      exit 1
    fi
  fi

  if [[ -v at_signkey ]]; then
    if ! gpg --list-secret-keys "$at_signkey" >/dev/null; then
      echo Cannot find signing key "$at_signkey". >&2
      exit 1
    fi
  fi
}

read_meta() {
  local metafile=$1
  while IFS== read var val; do
    if [[ $var =~ ^[[:space:]]*# ]]; then
      continue
    fi
    valid=(
      name puppetlabs_url puppetlabs_file
      installer_url installer_file
      repository_url repository_suite
      repository_source repository_contrib repository_nonfree
    )
    if [[ ${valid[@]} =~ "$var" ]]; then
      eval "at_$var=\$val"
      export at_$var
    fi
  done < "$metafile"
}

push_script() {
  scripts=("${scripts[@]}" "$@")
}

run_script() {
  local name=$1
  local script=$2
  local message=$3
  if [ -f "$script" ]; then
    echo $message
    if [ -x "$script" ]; then
      "$script"
    else
      cp "$script" "$at_build_dir"/autorun-$name
    fi
  else
    return 1
  fi
}

find_script() {
  local type=$1
  local fatal=$2
  local script=$3
  local message=$4
  if [[ -v at_local_release_dir ]] \
    && run_script "$script" "$at_local_release_dir"/mk$type-$script "$message"
    then
    :
  elif run_script "$script" "$at_lib_release"/mk$type-$script "$message"; then
    :
  elif run_script "$script" "$at_lib"/mk$type-$script "$message"; then
    :
  else
    if [[ "$fatal" == 0 ]]; then
      echo Skipping step: $message
    else
      echo Script not found: $script \($message\) >&2
      echo Aborting.
      exit 1
    fi
  fi
}

run_steps() {
  local type=$1

  for step in "${steps[@]}"; do
    script=${step%%:*}
    message=${step#*:}
    if [ "$script" != "${script#-}" ]; then
      echo $message
      ${script#-}
    else
      if find_script "$type" 0 "$script" "$message"; then
	push_script $script
      fi
    fi
  done
}

append_readme() {
  local type=$1

  if [ -z "$type" ]; then
    echo append_readme called without type. >&2
    return 2
  fi

  echo Creating README.atwan.
  cp "$at_lib"/README.$type "$at_build_dir"/README.atwan

  if [ -e "$at_lib_release"/mk$type-append-readme ]; then
    echo Appending $at_name-specific information to README.atwan.
    if [ -x "$at_lib_release"/mk$type-append-readme ]; then
      "$at_lib_release"/mk$type-append-readme >> "$at_build_dir"/README.atwan
    else
      cat "$at_lib_release"/mk$type-append-readme >> "$at_build_dir"/README.atwan
    fi
  fi
}

create_image() {
  local type=$1

  if [ -z "$type" ]; then
    echo create_image called without type. >&2
    return 2
  fi

  newfs=$(mktemp ${at_work_dir:+--tmpdir="$at_work_dir"})
  echo Generating output image in \""$newfs"\".
  "$at_lib_release"/mk$type-generate-iso "$newfs"

  if [[ -e "$at_out_file" ]]; then
    echo $at_out_file is in the way. >&2
    if [[ ! -v at_force ]]; then
      echo Leaving generated image as \""$newfs"\".
      exit 0
    fi

    echo Deleting it as instructed. >&2
    rm -f "$at_out_file"
  fi

  echo Moving temporary iso image to \""$at_out_file"\".
  mv "$newfs" "$at_out_file"

  echo Finished.
}

