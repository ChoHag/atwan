# The initialiser procedure creates an package which a server cloned from a
# gold image uses to give it an identity and establish trust with a central
# authority.
#
# Not all the steps listed below are required, and more can be added by
# plugins if so desired.

at_steps=(
  ## Initialise the initialiser build.
  # Atwan gives you a build directory and that's it.
  'environment:      Prepare the build environment.'
  # Use mkreadme or there'll be a file called 'readme' which isn't a readme.
  'mkreadme:         Create a README file.'
  'stop_initialiser: Stop automatic initialiser \(cron\).'

  'bootstrap:        Prepare a bootstrap image.'

  'authentication:   Update authentication credentials.'

  'networking:       Configure networking:'

  'maintenance:      Configure ongoing maintenance:'

  'configuration:    Configure configuration management:'

  ## Wrap up
  'autorun:          Compile the autorun script.'
  'sign:             Sign all the things.'
  'build:            Build the initialiser package ISO.'
)

at_out_file_default=initialiser--\$at_optarg_n.iso
at_out_file_default_display='initialiser--<fqdn>.iso'

ats_bootstrap_summary='[ -B [-C <command-line>] [-E <etc dir>] ]'
IFS='' read -r -d '' ats_bootstrap_options <<'EOF' || true
    -B: Create a bootstrap iso.
    -C: Boot-strap command-line options. Usually the name of a file in the /etc
        overlay directory.
    -E: A directory which will be stored in a tar archive and extracted to
	/etc on the bootstrap server.
	If it is not specified, a 'default' tarball will be included which will
	configure the plugin's cmdb server with its default configuration and a
	means of access (ssh).
EOF
# The bootstrap step only exists to claim CLI options and set variables. The
# standard atwan initialisation procedure deals with the location specified by
# -E in the configuration step.  All Atwan will actually do if the bootstrap
# step is not overriden, is copy the contents of <etc dir> over the top of /etc
# on the new server. This either needs to contain something appropriate, or a
# step needs to make note of at_optarg_B and at_optarg_E.  Mainly this is here
# rather than left to plugins in order to get this bit:
ats_bootstrap_getopts=BC:E:

ats_authentication_summary='[-p <secret>]'
ats_authentication_options='    -p: The superuser'\''s replacement password.'
ats_authentication_getopts=p:

ats_networking_summary='-n <fqdn> -i <ip> -d <dns-servers> [-m <netmask>] [-g <gateway>] [-h <http proxy>] [-l <logging server>]'
IFS='' read -r -d '' ats_networking_options <<'EOF' || true
    -n: The FQDN of the new server.
    -i: Host's IP address.
	DNS lookup is not implemented thus this parameter is required.
    -m: Host's netmask.
	Default: 255.255.255.0
	Until it is tested, short form netmasks are not supported.
    -g: Host's gateway.
	Default: Network address of host with a .1 suffix.
    -d: Host's DNS.
	A white-space separated list. Use quotes.
	Lookup from this machine's /etc/resolv.conf is not implemented.
    -h: HTTP Proxy.
    -l: (Unimplemented) The address to transmit log entries to.
EOF
ats_networking_getopts=n:i:m:g:d:h:l:
at_args_n=(1 string)
at_args_i=(1 string)
at_args_m=(0 string 255.255.255.0)
at_args_d=(1 string)

ats_maintenance_summary='[-y <repository address>] [-t <time server>] [-e <RNG setup address>]'
IFS='' read -r -d '' ats_maintenance_options <<'EOF' || true
    -y: Software repository address
    -t: (Unimplemented) The server from which to request the correct time
    -e: (Unimplemented) If set, describes how to configure entropy/the PRNG
EOF
ats_maintenance_getopts=y:t:e:

ats_configuration_summary='[-N <alternate name>] [-K <key options>] [-D <distribution>] [-A <signing authority>] -b <public key or certificate> [ -s | -U [ -s [-V <revocation file>] [-Z <authorised principals>] ] ]'
IFS='' read -r -d '' ats_configuration_options <<'EOF' || true
    SSH Host:
    -N: Additional names (comma-separated).
    -K: The key types to be generated specified as a colon-separated list.
        Default: ecdsa:rsa:dsa
    -D: Public key distribution method.
        Default: user-known-hosts
    -A: (Unimplemented) Signing authority.
    SSH User:
    -b: Public key or certificate file to include.
    -s: Send a certificate instead of a public key.
    -U: Install the certificate[s] system-wide.
    -V: KRL file to include.
    -Z: (Unimplemented) Something about AuthorizedPrincipalsFile.
EOF
ats_configuration_getopts=N:K:D:L:A:b:sV:UZ:
at_args_K=(1 string ecdsa:rsa:dsa)
at_args_D=(0 string user-known-hosts)
at_args_b=(1 string $HOME/.ssh/id_rsa.pub)
at_args_Z=(0 multi-string)

# build is always the final step.
ats_build_summary='[-k <gpg signing key>] [-F <format>]'
IFS='' read -r -d '' ats_build_options <<'EOF' || true
    -k: GPG key id to use to sign the initialiser iso.
    -F: Output file format (iso, tgz).
        Default: iso
EOF
ats_build_getopts=k:F:
at_args_k=(0 gpg:sec)
at_args_F=(1 string iso)

further_checks() {
  if [[ -v at_optarg_E && ! -v at_optarg_B ]]; then
    echo 'Overlay /etc directory (-E) can only be specified in a bootstrap (-B) image.' >&2
    return 1
  fi

  if [[ -v at_optarg_M && -v at_optarg_H ]]; then
    echo 'The ssh public key (-M) and known_hosts file (-H) options are incompatible.' >&2
    return 1
  fi

  if [[ -v at_optarg_S && $at_optarg_S =~ '^/dev/u?random$' && ! -v at_optarg_K ]]; then
    at_optarg_K=256
  fi

  if [[ -v at_optarg_V || -v at_optarg_Z ]]; then
    if ! [[ -v at_optarg_s && -v at_optarg_U ]]; then
      echo 'Revocation file (-V) and authorised principals (-Z) are only valid with system-wide certificates.' >&2
      return 1
    fi
  fi
}
